local env = {
    -- Roblox сервисы
    Players = game:GetService("Players"),
    Workspace = game:GetService("Workspace"),
    UserInputService = game:GetService("UserInputService"),
    RunService = game:GetService("RunService"),
    TweenService = game:GetService("TweenService"),
    -- Часто используемые объекты
    Camera = workspace.CurrentCamera,
    LocalPlayer = game:GetService("Players").LocalPlayer,
    -- Части тела
    r15 = {
        "Head","UpperTorso","LowerTorso","HumanoidRootPart","LeftUpperArm","LeftLowerArm","LeftHand",
        "RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg","LeftFoot",
        "RightUpperLeg","RightLowerLeg","RightFoot"
    },
    -- Математика и утилиты
    math = math,
    CFrame = CFrame,
    Vector3 = Vector3,
    Vector2 = Vector2,
    tick = tick,
    huge = math.huge,
}

getgenv().library, getgenv().library_flags, getgenv().subs = loadstring(game:HttpGet("https://raw.githubusercontent.com/xzcReasd/WhoAsking/refs/heads/main/Uilib"))();
getgenv().Wait = getgenv().subs.Wait -- Only returns if the GUI has not been terminated. For 'while Wait() do' loops

getgenv().PepsisWorld = getgenv().library:CreateWindow({
    Name = "NIGGER.TAPBOT",
    Themeable = {
        Info = "u tapped"
    }
})
getgenv().Rage = getgenv().PepsisWorld:CreateTab({
    Name = "rage"
})
getgenv().Misc = getgenv().PepsisWorld:CreateTab({
    Name = "misc"
})
getgenv().Visuals = getgenv().PepsisWorld:CreateTab({
    Name = "visuals"
})
getgenv().Player = getgenv().PepsisWorld:CreateTab({
    Name = "player"
})

getgenv().RagebotSection = getgenv().Rage:CreateSection({
    Name = "Ragebot"
})

getgenv().ragebotToggle = getgenv().RagebotSection:AddToggle({
    Name = "Ragebot Enabled",
    Flag = "ragebot_enabled",
    Value = false,
    Callback = function(val)
        getgenv().SA = getgenv().SA or {O = {}, S = {}}
        getgenv().SA.O.E = val
    end
})

getgenv().predXZ = getgenv().RagebotSection:AddTextbox({
    Name = "Prediction XZ",
    Flag = "ragebot_pred_xz",
    Value = 0.12362,
    Type = "number",
    Callback = function(val, old)
        getgenv().SA = getgenv().SA or {O = {}, S = {}}
        getgenv().SA.S.PXZ = tonumber(val) or 0
        getgenv().library:Notify({Text = "Prediction XZ установлен на: " .. tostring(val), Time = 2})
    end
})

getgenv().predY = getgenv().RagebotSection:AddTextbox({
    Name = "Prediction Y",
    Flag = "ragebot_pred_y",
    Value = 0.12362,
    Type = "number",
    Callback = function(val, old)
        getgenv().SA = getgenv().SA or {O = {}, S = {}}
        getgenv().SA.S.PY = tonumber(val) or 0
        getgenv().library:Notify({Text = "Prediction Y установлен на: " .. tostring(val), Time = 2})
    end
})

getgenv().aimingMethodDropdown = getgenv().RagebotSection:AddDropdown({
    Name = "AimingMethod",
    Flag = "ragebot_aiming_method",
    List = {"index", "namecall"},
    Value = "index",
    Callback = function(val)
        getgenv().SA = getgenv().SA or {O = {}, S = {}}
        getgenv().SA.AM = val
        getgenv().library:Notify({Text = "AimingMethod: " .. tostring(val), Time = 2})
    end
})

getgenv().S = {
    Plrs = env.Players,
    Wksp = env.Workspace,
    UIS = env.UserInputService,
    RunS = env.RunService,
    Cam = env.Camera,
    LPlr = env.LocalPlayer,
    TPlr = nil,
    TP = nil,
    -- другие переменные по необходимости
}

getgenv().PredSec = getgenv().Rage:CreateSection({ Name = "Pred/Res/Offs", Side = "Left" })
function ePRED() getgenv().SA = getgenv().SA or {O = {}, S = {}, PRED = {}, PARTS = {}, CHECKS = {}}; getgenv().SA.PRED = getgenv().SA.PRED or {}; return getgenv().SA.PRED end

getgenv().PredMode = getgenv().PredSec:AddDropdown({
    Name = "PredMode",
    Flag = "pred_mode",
    List = {"Default", "Sets", "Math", "Calc"},
    Value = "Default",
    Callback = function(v) local p = ePRED(); p.Mode = v or "Default"; getgenv().library:Notify({Text = "PredMode: "..tostring(v), Time = 2}) end
})
getgenv().APred = getgenv().PredSec:AddToggle({
    Name = "AutoPred",
    Flag = "a_pred",
    Value = false,
    Callback = function(v) local p = ePRED(); p.Auto = v and true or false; getgenv().library:Notify({Text = "APred: "..tostring(v), Time = 2}) end
})
getgenv().Ping = getgenv().PredSec:AddTextbox({
    Name = "Ping",
    Flag = "ping",
    Value = 50,
    Type = "number",
    Callback = function(v) local p = ePRED(); p.Ping = tonumber(v) or 50; getgenv().library:Notify({Text = "Ping: "..tostring(v), Time = 2}) end
})
getgenv().Div = getgenv().PredSec:AddToggle({
    Name = "Division",
    Flag = "div",
    Value = false,
    Callback = function(v) local p = ePRED(); p.Division = v and true or false; getgenv().library:Notify({Text = "Div: "..tostring(v), Time = 2}) end
})
getgenv().Res = getgenv().PredSec:AddDropdown({
    Name = "Res",
    Flag = "res",
    List = {"None", "Recalc", "MoveDir", "LookV", "Vel", "MoveD", "CalcCF"},
    Value = "None",
    Callback = function(v) local p = ePRED(); p.Resolver = v or "None"; getgenv().library:Notify({Text = "Res: "..tostring(v), Time = 2}) end
})
getgenv().JmpOfs = getgenv().PredSec:AddTextbox({
    Name = "JmpOfs",
    Flag = "jmp_ofs",
    Value = 0,
    Type = "number",
    Callback = function(v) local p = ePRED(); p.JumpOffset = tonumber(v) or 0; getgenv().library:Notify({Text = "JmpOfs: "..tostring(v), Time = 2}) end
})
getgenv().FallOfs = getgenv().PredSec:AddTextbox({
    Name = "FallOfs",
    Flag = "fall_ofs",
    Value = 0,
    Type = "number",
    Callback = function(v) local p = ePRED(); p.FallOffset = tonumber(v) or 0; getgenv().library:Notify({Text = "FallOfs: "..tostring(v), Time = 2}) end
})

getgenv().PartSec = getgenv().Rage:CreateSection({ Name = "Parts", Side = "Right" })
function ePARTS() getgenv().SA.PARTS = getgenv().SA.PARTS or {}; return getgenv().SA.PARTS end
getgenv().r15 = env.r15
getgenv().AimPrt = getgenv().PartSec:AddDropdown({
    Name = "AimPrt",
    Flag = "aim_prt",
    List = getgenv().r15,
    Value = "HumanoidRootPart",
    Callback = function(v) local p = ePARTS(); p.SelectedPart = v or "HumanoidRootPart" end
})
getgenv().AirPrt = getgenv().PartSec:AddDropdown({
    Name = "AirPrt",
    Flag = "air_prt",
    List = getgenv().r15,
    Value = "RightFoot",
    Callback = function(v) local p = ePARTS(); p.AirPart = v or "RightFoot" end
})

getgenv().ChkSec = getgenv().Rage:CreateSection({ Name = "Checks", Side = "Right" })
function eCHK() getgenv().SA.CHECKS = getgenv().SA.CHECKS or {}; return getgenv().SA.CHECKS end
getgenv().KO = getgenv().ChkSec:AddToggle({ Name = "KO", Flag = "ko", Value = true, Callback = function(v) local c = eCHK(); c.KOCheck = v end })
getgenv().Wall = getgenv().ChkSec:AddToggle({ Name = "Wall", Flag = "wall", Value = false, Callback = function(v) local c = eCHK(); c.WallCheck = v end })
getgenv().Frnd = getgenv().ChkSec:AddToggle({ Name = "Friend", Flag = "frnd", Value = false, Callback = function(v) local c = eCHK(); c.FriendCheck = v end })
getgenv().Veh = getgenv().ChkSec:AddToggle({ Name = "Vehicle", Flag = "veh", Value = false, Callback = function(v) local c = eCHK(); c.VehicleCheck = v end })
getgenv().Seat = getgenv().ChkSec:AddToggle({ Name = "Seat", Flag = "seat", Value = false, Callback = function(v) local c = eCHK(); c.SeatedCheck = v end })
getgenv().Death = getgenv().ChkSec:AddToggle({ Name = "Death", Flag = "death", Value = false, Callback = function(v) local c = eCHK(); c.DeathCheck = v end })

getgenv().targetPickKey = getgenv().RagebotSection:AddKeybind({
    Name = "Target Pick Key",
    Flag = "ragebot_target_pick_key",
    Value = nil, -- по умолчанию бинда нет
    Callback = function(val)
        getgenv().SA = getgenv().SA or {O = {}, S = {}}
        if val and typeof(val) == "EnumItem" then
            getgenv().SA.O.TK = tostring(val):gsub("Enum.KeyCode.", "")
        else
            getgenv().SA.O.TK = nil
        end
    end
})

-- Интеграция аимбота (один раз)
if not getgenv()._ragebot_loaded then
    loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() --ac bypass just put in first strings of script
    getgenv()._ragebot_loaded = true
    -- Установим дефолтные значения для SA, если не были заданы
    getgenv().SA = getgenv().SA or {O = {}, S = {}}
    getgenv().SA.O.E = getgenv().ragebotToggle:Get()
    getgenv().SA.O.TK = tostring(getgenv().targetPickKey:Get()):gsub("Enum.KeyCode.", "")
    getgenv().SA.S.PXZ = tonumber(getgenv().predXZ:Get()) or 0.12362
    getgenv().SA.S.PY = tonumber(getgenv().predY:Get()) or 0.12362
    getgenv().SA.S.P = "HumanoidRootPart"
    getgenv().SA.PRED = getgenv().SA.PRED or {}
    getgenv().SA.PRED.Mode = getgenv().PredMode:Get() or "Default"
    getgenv().SA.PRED.Auto = getgenv().APred:Get()
    getgenv().SA.PRED.Ping = tonumber(getgenv().Ping:Get()) or 50
    getgenv().SA.PRED.Division = getgenv().Div:Get()
    getgenv().SA.PRED.Resolver = getgenv().Res:Get() or "None"
    getgenv().SA.PRED.JumpOffset = tonumber(getgenv().JmpOfs:Get()) or 0
    getgenv().SA.PRED.FallOffset = tonumber(getgenv().FallOfs:Get()) or 0
    getgenv().SA.PARTS = getgenv().SA.PARTS or {}
    getgenv().SA.PARTS.SelectedPart = getgenv().AimPrt:Get() or "HumanoidRootPart"
    getgenv().SA.PARTS.AirPart = getgenv().AirPrt:Get() or "RightFoot"
    getgenv().SA.CHECKS = getgenv().SA.CHECKS or {}
    getgenv().SA.CHECKS.KOCheck = getgenv().KO:Get()
    getgenv().SA.CHECKS.WallCheck = getgenv().Wall:Get()
    getgenv().SA.CHECKS.FriendCheck = getgenv().Frnd:Get()
    getgenv().SA.CHECKS.VehicleCheck = getgenv().Veh:Get()
    getgenv().SA.CHECKS.SeatedCheck = getgenv().Seat:Get()
    getgenv().SA.CHECKS.DeathCheck = getgenv().Death:Get()
end

-- Логика рейджбота (аимбота)
do
    getgenv().TP = nil -- Вынесено в do, чтобы сбрасывать цель
    function syncSA()
        getgenv().SA = getgenv().SA or {O = {}, S = {}, PRED = {}, PARTS = {}, CHECKS = {}}
        getgenv().SA.PRED = getgenv().SA.PRED or {}
        getgenv().SA.O.E = getgenv().library_flags["ragebot_enabled"]
        getgenv().key = getgenv().library_flags["ragebot_target_pick_key"]
        if typeof(getgenv().key) == "EnumItem" then
            getgenv().SA.O.TK = tostring(getgenv().key):gsub("Enum.KeyCode.", "")
        else
            getgenv().SA.O.TK = nil
        end
        getgenv().SA.S.PXZ = tonumber(getgenv().library_flags["ragebot_pred_xz"]) or 0.12362
        getgenv().SA.S.PY = tonumber(getgenv().library_flags["ragebot_pred_y"]) or 0.12362
        getgenv().SA.S.P = "HumanoidRootPart"
        getgenv().SA.AM = getgenv().library_flags["ragebot_aiming_method"] or "index"
        getgenv().pred = getgenv().SA.PRED
        getgenv().pred.Mode = getgenv().library_flags["ragebot_prediction_mode"] or "Default"
        getgenv().pred.Auto = getgenv().library_flags["ragebot_auto_prediction"] and true or false
        getgenv().pred.Ping = tonumber(getgenv().library_flags["ragebot_ping_value"]) or 50
        getgenv().pred.Division = getgenv().library_flags["ragebot_division_mode"] and true or false
        getgenv().pred.Resolver = getgenv().library_flags["ragebot_resolver"] or "None"
        getgenv().pred.JumpOffset = tonumber(getgenv().library_flags["ragebot_jump_offset"]) or 0
        getgenv().pred.FallOffset = tonumber(getgenv().library_flags["ragebot_fall_offset"]) or 0
        getgenv().SA.PARTS = getgenv().SA.PARTS or {}
        getgenv().SA.PARTS.SelectedPart = getgenv().AimPrt:Get() or "HumanoidRootPart"
        getgenv().SA.PARTS.AirPart = getgenv().AirPrt:Get() or "RightFoot"
        getgenv().SA.CHECKS = getgenv().SA.CHECKS or {}
        getgenv().SA.CHECKS.KOCheck = getgenv().KO:Get()
        getgenv().SA.CHECKS.WallCheck = getgenv().Wall:Get()
        getgenv().SA.CHECKS.FriendCheck = getgenv().Frnd:Get()
        getgenv().SA.CHECKS.VehicleCheck = getgenv().Veh:Get()
        getgenv().SA.CHECKS.SeatedCheck = getgenv().Seat:Get()
        getgenv().SA.CHECKS.DeathCheck = getgenv().Death:Get()
    end

    -- Синхронизация при изменении UI
    getgenv().ragebotToggle.Options.Callback = function(val)
        syncSA()
    end
    getgenv().targetPickKey.Options.Callback = function(val)
        syncSA()
    end
    getgenv().predXZ.Options.Callback = function(val)
        syncSA()
    end
    getgenv().predY.Options.Callback = function(val)
        syncSA()
    end
    getgenv().aimingMethodDropdown.Options.Callback = function(val)
        getgenv().SA.AM = val
        updateHooks()
    end
    getgenv().PredMode.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.Mode = v
    end
    getgenv().APred.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.Auto = v
    end
    getgenv().Ping.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.Ping = tonumber(v) or 50
    end
    getgenv().Div.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.Division = v
    end
    getgenv().Res.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.Resolver = v
    end
    getgenv().JmpOfs.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.JumpOffset = tonumber(v) or 0
    end
    getgenv().FallOfs.Options.Callback = function(v)
        getgenv().pred = ePRED()
        getgenv().pred.FallOffset = tonumber(v) or 0
    end
    getgenv().AimPrt.Options.Callback = function(v)
        getgenv().parts = ePARTS()
        getgenv().parts.SelectedPart = v
    end
    getgenv().AirPrt.Options.Callback = function(v)
        getgenv().parts = ePARTS()
        getgenv().parts.AirPart = v
    end
    getgenv().KO.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.KOCheck = v end
    getgenv().Wall.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.WallCheck = v end
    getgenv().Frnd.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.FriendCheck = v end
    getgenv().Veh.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.VehicleCheck = v end
    getgenv().Seat.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.SeatedCheck = v end
    getgenv().Death.Options.Callback = function(v) getgenv().checks = eCHK(); getgenv().checks.DeathCheck = v end

    -- Инициализация SA при запуске
    syncSA()

    -- Основная логика аимбота
    function startRagebot()
        if getgenv().L then return end
        getgenv().SA = getgenv().SA
        getgenv().P = game:GetService("Players")
        getgenv().W = game:GetService("Workspace")
        getgenv().UI = game:GetService("UserInputService")
        getgenv().LP = getgenv().P.LocalPlayer
        getgenv().C = getgenv().W.CurrentCamera
        getgenv().FFC = game.FindFirstChild
        getgenv().GP = getgenv().P.GetPlayers
        getgenv().GML = getgenv().UI.GetMouseLocation
        getgenv().WTVP = getgenv().C.WorldToViewportPoint
        getgenv().NV2 = env.Vector2.new
        getgenv().NC = env.CFrame.new
        getgenv().I = env.huge
        getgenv().LPOS = nil
        getgenv().LUT = nil
        getgenv().PPOS = nil
        function IPA(p) return p.Character and getgenv().FFC(p.Character, "Humanoid") and p.Character.Humanoid.Health > 0 end
        function GCP()
            local SD = getgenv().I
            local CP = nil
            local MP = getgenv().GML(getgenv().UI)
            local PT = getgenv().SA.S.P
            for _, p in next, getgenv().GP(getgenv().P) do
                local c = p.Character
                if p ~= getgenv().LP and IPA(p) and c:FindFirstChild(PT) then
                    local OSP, IOS = getgenv().WTVP(getgenv().C, c[PT].Position)
                    local D = (getgenv().NV2(OSP.X, OSP.Y) - MP).Magnitude
                    if D < SD and IOS then CP = p SD = D end
                end
            end
            return CP
        end
        function GPP(tp)
            if tp and tp.Character and tp.Character:FindFirstChild(getgenv().SA.S.P) then
                local APP = tp.Character[getgenv().SA.S.P].Position
                if not getgenv().LPOS or not getgenv().LUT then
                    getgenv().LPOS = APP
                    getgenv().LUT = getgenv().tick()
                    local PPOS = APP
                    return PPOS
                end
                local CT = getgenv().tick()
                local DT = CT - getgenv().LUT
                local V = tp.Character[getgenv().SA.S.P].Velocity
                local PPOS = APP + env.Vector3.new(V.X * getgenv().SA.S.PXZ, V.Y * getgenv().SA.S.PY, V.Z * getgenv().SA.S.PXZ)
                getgenv().LUT = CT
                getgenv().LPOS = APP
                return PPOS
            end
            return nil
        end
        -- Hooks
        getgenv().MT = getrawmetatable(game)
        -- getgenv().oldIndex, getgenv().oldNamecall -- удалено, не нужно
        local function setIndexHook()
            if getgenv().oldIndex then return end
            getgenv().oldIndex = hookmetamethod(game, "__index", function(self, k)
                if not checkcaller() and self == getgenv().LP:GetMouse() and getgenv().SA.O.E and getgenv().TP then
                    if k == "Hit" or k == "Target" then
                        if IPA(getgenv().TP) and getgenv().TP.Character:FindFirstChild(getgenv().SA.S.P) then
                            getgenv().FP = GPP(getgenv().TP)
                            getgenv().TPT = getgenv().TP.Character[getgenv().SA.S.P]
                            return k == "Hit" and (getgenv().FP and getgenv().NC(getgenv().FP) or getgenv().NC(getgenv().TPT.Position)) or getgenv().TPT
                        else
                            getgenv().TP = nil
                        end
                    end
                end
                return getgenv().oldIndex(self, k)
            end)
        end
        local function setNamecallHook()
            if getgenv().oldNamecall then return end
            getgenv().Argumen = {"UpdateMousePos", "GetMousePos", "MousePos", "MOUSE", "MousePosUpdate", "UpdateMousePosI2", "UpdateMousePosI", "UpdateAim"}
            getgenv().oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
                getgenv().args = {...}
                getgenv().method = getnamecallmethod()
                if getgenv().method == "FireServer" and getgenv().SA.O.E and getgenv().TP and IPA(getgenv().TP) and getgenv().TP.Character:FindFirstChild(getgenv().SA.S.P) then
                    if #getgenv().args >= 2 then
                        for _, methodName in ipairs(getgenv().Argumen) do
                            if getgenv().args[2] == methodName then
                                getgenv().args[3] = GPP(getgenv().TP)
                                return getgenv().oldNamecall(self, unpack(getgenv().args))
                            end
                        end
                    end
                end
                return getgenv().oldNamecall(self, ...)
            end)
        end
        local function resetHooks()
            if getgenv().oldIndex then
                hookmetamethod(game, "__index", getgenv().oldIndex)
                getgenv().oldIndex = nil
            end
            if getgenv().oldNamecall then
                hookmetamethod(game, "__namecall", getgenv().oldNamecall)
                getgenv().oldNamecall = nil
            end
        end
        local function updateHooks()
            resetHooks()
            if getgenv().SA.AM == "namecall" then
                setNamecallHook()
            else
                setIndexHook()
            end
        end
        -- Инициализация хуков
        updateHooks()

        -- Prediction tables
        getgenv().predictionTable = {
            {20, 0.08960952}, {30, 0.11252476}, {50, 0.13544}, {65, 0.1264236}, {70, 0.12533}, {80, 0.139340},
            {100, 0.141987}, {110, 0.144634}, {120, 0.147281}, {130, 0.149928}, {140, 0.152575}, {150, 0.155222},
            {160, 0.157869}, {170, 0.160516}, {180, 0.163163}, {190, 0.165810}, {200, 0.168457}, {210, 0.171104},
            {220, 0.173751}, {230, 0.176398}, {240, 0.179045}, {250, 0.181692}, {260, 0.184339}, {270, 0.186986},
            {280, 0.189633}, {290, 0.192280}, {300, 0.194927}
        }
        getgenv().sigma_table = {
            {0, 0.04070}, {30, 0.05078}
        }
        function calculate(Ping)
            return (Ping / 1000) + 0.037
        end
        function fiCl(tb, pg)
            getgenv().clVa, getgenv().clDi = nil, env.huge
            for _, en in ipairs(tb) do
                getgenv().di = math.abs(pg - en[1])
                if getgenv().di < getgenv().clDi then getgenv().clDi, getgenv().clVa = getgenv().di, en[2] end
            end
            return getgenv().clVa
        end
        function updatePredictionValue(pg, SA)
            local pred = SA.PRED or {}
            if pg and pred.Auto then
                local mo = pred.Mode
                if mo == "Default" or mo == "Sets Based" then
                    local clVa = fiCl(mo == "Sets Based" and getgenv().predictionTable or getgenv().sigma_table, pg)
                    if clVa then
                        pred.Horizontal = clVa
                        pred.Vertical = clVa * (mo == "Sets Based" and 0.910 or 1)
                    end
                elseif mo == "Math Based" then
                    local function gePr(fa, ad)
                        return fa * math.log(pg + 1) + ad
                    end
                    pred.Horizontal = gePr(0.105, -0.342665)
                    pred.Vertical = gePr(0.1, -0.3405)
                elseif mo == "Calculate" then
                    local calcValue = calculate(pg)
                    pred.Horizontal = calcValue
                    pred.Vertical = calcValue
                end
            end
            SA.PRED = pred
        end
        -- Resolver calculations for target position
        function TargetFuturePosition(SA, TargetPlr, lastPos, lastTick, currentTick)
            local pred = SA.PRED or {}
            local velocity = env.Vector3.new(0, 0, 0)
            local currentPos = TargetPlr.Character.HumanoidRootPart.Position
            local predictedPos = currentPos
            local horizontalPrediction = pred.Horizontal or SA.S.PXZ
            local verticalPrediction = pred.Vertical or SA.S.PY
            local jumpOffset = pred.JumpOffset or 0
            local fallOffset = pred.FallOffset or 0
            local resolver = pred.Resolver or "None"
            if resolver == "Recalculate" then
                if lastPos then
                    local delta = currentTick - lastTick
                    if delta > 0 then
                        local positionDifference = currentPos - lastPos
                        velocity = positionDifference / delta
                    end
                end
            elseif resolver == "MoveDirection" then
                local humanoid = TargetPlr.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    velocity = humanoid.MoveDirection * humanoid.WalkSpeed
                end
            elseif resolver == "LookVector" then
                velocity = TargetPlr.Character.HumanoidRootPart.CFrame.LookVector * (horizontalPrediction or 1) * 1.5
            elseif resolver == "Velocity" then
                velocity = TargetPlr.Character.HumanoidRootPart.Velocity
            elseif resolver == "Move direction" then
                local humanoid = TargetPlr.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    velocity = humanoid.MoveDirection * ((horizontalPrediction or 1) * 10)
                end
            elseif resolver == "Calculate CFrame" then
                if lastPos and lastTick then
                    local deltaTime = currentTick - lastTick
                    if deltaTime > 0 then
                        local distance = (currentPos - lastPos).Magnitude
                        if distance < 0.001 then
                            predictedPos = currentPos
                        else
                            local predictedDistance = (distance / deltaTime) * (0.1 * (horizontalPrediction * 10))
                            predictedPos = currentPos + (currentPos - lastPos).Unit * predictedDistance
                            local yChange = (currentPos.Y - lastPos.Y) / deltaTime * (0.1 * verticalPrediction)
                            predictedPos = predictedPos + env.Vector3.new(0, yChange, 0)
                        end
                    end
                end
            else
                velocity = TargetPlr.Character.HumanoidRootPart.AssemblyLinearVelocity or TargetPlr.Character.HumanoidRootPart.Velocity
            end
            if resolver ~= "Calculate CFrame" then
                if pred.Division then
                    predictedPos = env.Vector3.new(
                        currentPos.X + (velocity.X / horizontalPrediction),
                        currentPos.Y + (velocity.Y / verticalPrediction),
                        currentPos.Z + (velocity.Z / horizontalPrediction)
                    ) + env.Vector3.new(0, jumpOffset + fallOffset, 0)
                else
                    predictedPos = env.Vector3.new(
                        currentPos.X + (velocity.X * horizontalPrediction),
                        currentPos.Y + (velocity.Y * verticalPrediction),
                        currentPos.Z + (velocity.Z * horizontalPrediction)
                    ) + env.Vector3.new(0, jumpOffset + fallOffset, 0)
                end
            end
            return env.CFrame.new(predictedPos)
        end
        -- Остальной код (UI.InputBegan, TP и т.д.)
        getgenv().UI.InputBegan:Connect(function(i, gpe)
            if not gpe and getgenv().SA.O.TK and i.KeyCode == Enum.KeyCode[getgenv().SA.O.TK] then
                if getgenv().TP then
                    getgenv().TP = nil -- Сброс цели при повторном нажатии
                else
                    getgenv().TP = GCP()
                end
            end
        end)
        getgenv().LP.CharacterAdded:Connect(function() getgenv().TP = nil end)
        getgenv().L = true
    end

    -- Запуск логики, если не была запущена
    if not getgenv().L then
        startRagebot()
    end
end

-- Вставить в RunService/Stepped или аналогичный цикл:
getgenv().S.RunS.Stepped:Connect(function()
    if getgenv().S.TPlr and getgenv().SA.CHECKS and getgenv().SA.CHECKS.DeathCheck then
        getgenv().h = getgenv().S.TPlr.Character and getgenv().S.TPlr.Character:FindFirstChildOfClass("Humanoid")
        if not getgenv().h or getgenv().h.Health <= 0 then
            getgenv().S.TPlr = nil
        end
    end
end)

-- =====================
-- DESYNC UI (полный каркас, исправленный Keybind и Colorpicker, сбалансированное распределение секций)
-- =====================
getgenv().DesyncTab = getgenv().PepsisWorld:CreateTab({ Name = "desync" })

-- Секции слева
getgenv().DesyncMainSection = getgenv().DesyncTab:CreateSection({ Name = "Main", Side = "Left" })
getgenv().DesyncVoidSection = getgenv().DesyncTab:CreateSection({ Name = "Void", Side = "Left" })
getgenv().DesyncVisualSection = getgenv().DesyncTab:CreateSection({ Name = "Visuals", Side = "Left" })
-- Удаляем TargetStrafe из UI
-- (блок Target Strafe Section полностью удалён)

-- Секции справа
getgenv().DesyncXSection = getgenv().DesyncTab:CreateSection({ Name = "X Position", Side = "Right" })
getgenv().DesyncYSection = getgenv().DesyncTab:CreateSection({ Name = "Y Position", Side = "Right" })
getgenv().DesyncZSection = getgenv().DesyncTab:CreateSection({ Name = "Z Position", Side = "Right" })
getgenv().DesyncPitchSection = getgenv().DesyncTab:CreateSection({ Name = "Pitch", Side = "Right" })
getgenv().DesyncYawSection = getgenv().DesyncTab:CreateSection({ Name = "Yaw", Side = "Right" })
getgenv().DesyncRollSection = getgenv().DesyncTab:CreateSection({ Name = "Roll", Side = "Right" })
getgenv().DesyncHookSection = getgenv().DesyncTab:CreateSection({ Name = "Hook", Side = "Left" })

-- =====================
-- Глобальные флаги состояния Desync
getgenv().DesyncState = {
    Active = false, -- одно состояние (тогл)
    Void = false, -- void режим
}

-- Main Section с одним состоянием
getgenv().DesyncMainSection:AddToggle({
    Name = "Enabled",
    Flag = "desync_enabled",
    Value = false,
    Callback = function(v)
        getgenv().DesyncState.Active = v
    end,
    Keybind = {
        Name = "Desync Key",
        Flag = "desync_key",
        Callback = function()
            getgenv().DesyncState.Active = not getgenv().DesyncState.Active
        end
    }
})

-- Void Section
getgenv().DesyncVoidSection:AddToggle({
    Name = "Void",
    Flag = "desync_void",
    Value = false,
    Callback = function(v)
        getgenv().DesyncState.Void = v
        if v then
            getgenv().Desync:SetStatus(true)
            getgenv().Desync:OverwritePosition(Vector3.new(9e9, -9e9, 9e9))
        else
            getgenv().Desync:SetStatus(nil)
            getgenv().Desync:RemoveOverwrite()
        end
    end,
    Keybind = {
        Name = "Void Key",
        Flag = "desync_void_key",
        Callback = function(isDown)
            if isDown and getgenv().DesyncState.Void then
                getgenv().Desync:SetStatus(true)
                getgenv().Desync:OverwritePosition(Vector3.new(9e9, -9e9, 9e9))
            else
                getgenv().Desync:SetStatus(nil)
                getgenv().Desync:RemoveOverwrite()
            end
        end
    }
})

-- Visuals Section
getgenv().DesyncVisualSection:AddToggle({ Name = "Visualize", Flag = "desync_vis", Value = false })
getgenv().DesyncVisualSection:AddColorpicker({ Name = "Desync Color", Flag = "desync_vis_color", Callback = function()
    if getgenv().Desync and getgenv().Desync.CloneColorUpdate then
        getgenv().Desync:CloneColorUpdate()
    end
end })

-- Удаляем TargetStrafe из UI
-- (блок Target Strafe Section полностью удалён)

-- Helper for position sections (исправлено: корректные min/max)
local function addPositionSection(section, prefix, minVal, maxVal, deg)
    section:AddToggle({ Name = prefix .. (deg and " Position" or " Position"), Flag = "desync_"..string.lower(prefix), Value = false })
    section:AddDropdown({
        Name = prefix .. " Mode",
        Flag = "desync_mode_"..string.lower(prefix),
        List = {"Static", "Lerp", "Random"},
        Value = "Static"
    })
    section:AddSlider({ Name = "Min", Flag = "desync_min_"..string.lower(prefix), Value = minVal, Min = minVal, Max = maxVal, Decimals = 1, Suffix = deg and "°" or "st" })
    section:AddSlider({ Name = "Max", Flag = "desync_max_"..string.lower(prefix), Value = maxVal, Min = minVal, Max = maxVal, Decimals = 1, Suffix = deg and "°" or "st" })
    section:AddSlider({ Name = "Value", Flag = "desync_val_"..string.lower(prefix), Value = 0, Min = minVal, Max = maxVal, Decimals = 1, Suffix = deg and "°" or "st" })
    section:AddSlider({ Name = "Lerp Speed", Flag = "desync_speed_"..string.lower(prefix), Value = 1, Min = 1, Max = 30, Decimals = 1 })
end

-- X/Y/Z: -300..300, Pitch/Yaw/Roll: -360..360 (градусы)
addPositionSection(getgenv().DesyncXSection, "X", -300, 300, false)
addPositionSection(getgenv().DesyncYSection, "Y", -300, 300, false)
addPositionSection(getgenv().DesyncZSection, "Z", -300, 300, false)
addPositionSection(getgenv().DesyncPitchSection, "Pitch", -360, 360, true)
addPositionSection(getgenv().DesyncYawSection, "Yaw", -360, 360, true)
addPositionSection(getgenv().DesyncRollSection, "Roll", -360, 360, true)

-- Hook Section
getgenv().DesyncHookSection:AddToggle({ Name = "Use Hook", Flag = "desync_hook", Value = false })
-- =====================
-- КОНЕЦ DESYNC UI (полный каркас, исправленный Keybind и Colorpicker, сбалансированное распределение секций)
-- =====================

-- =====================
-- DESYNC LOGIC (фикс: материал клона, раздельные состояния, void, сброс после смерти)
-- =====================

local player = game:GetService("Players").LocalPlayer
getgenv().Controller = getgenv().Controller or {}
local function updateController(char)
    getgenv().Controller.Character = char
    getgenv().Controller.RootPart = char:FindFirstChild("HumanoidRootPart")
    getgenv().Controller.Humanoid = char:FindFirstChildOfClass("Humanoid")
end
if player.Character then updateController(player.Character) end
player.CharacterAdded:Connect(function(char)
    updateController(char)
    -- Не сбрасываем состояния DesyncState!
    -- Пересоздаём клон если был активен визуал
    if getgenv().Desync and getgenv().library_flags and getgenv().library_flags["desync_vis"] then
        getgenv().Desync:DestroyClonedCharacter()
        getgenv().Desync:CloneCharacter()
    end
end)

local Flags = getgenv().library_flags
local Utility = Utility or {}
local Visuals = Visuals or {}
local mathsin, mathrad, mathrandom, osclock = math.sin, math.rad, math.random, os.clock
local Vector3new = Vector3.new
local CFramenew = CFrame.new
local CFrameAngles = CFrame.Angles
local Aimbot = Aimbot or {}
local SilentAim = SilentAim or {}
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local Desync = {
    Positions = { Old = nil, New = nil },
    Overwriten = nil,
    ClonedCharacter = nil,
    NewStatus = nil,
}
getgenv().Desync = Desync

function Desync:Active()
    -- Активно если включён тогл или void
    return ((getgenv().DesyncState.Active or getgenv().DesyncState.Void or self.NewStatus) and getgenv().Controller.RootPart)
end

function Desync:SetStatus(status)
    self.NewStatus = status
end

function Desync:GetPositions()
    local Positions = self.Positions
    local Status = self:Active()
    if not Status then return end
    return Positions.Old, Positions.New
end

function Desync:RemoveOffset()
    local Positions = self.Positions
    local Status = self:Active()
    if not (Status and Positions.Old and Positions.New) then return end
    if Utility.CFrameToVector3 then
        Camera.CFrame = Camera.CFrame - Utility:CFrameToVector3(Positions.New - Utility:CFrameToVector3(Positions.Old))
    end
end

function Desync:GetLerpValue(pulse, min, max, speed)
    speed = speed or 1
    local NormalizedSin = (mathsin(pulse * speed) + 1) / 2
    return min + NormalizedSin * (max - min)
end

function Desync:GetValue(pos_type)
    local ClockPulse = osclock()
    local Mode = Flags["desync_mode_" .. pos_type] or "Static"
    local Min = tonumber(Flags["desync_min_" .. pos_type]) or 0
    local Max = tonumber(Flags["desync_max_" .. pos_type]) or 0
    local Val = tonumber(Flags["desync_val_" .. pos_type]) or 0
    local Speed = tonumber(Flags["desync_speed_" .. pos_type]) or 1
    if Flags["desync_" .. pos_type] then
        if Mode == "Static" then
            return Val
        elseif Mode == "Lerp" then
            return self:GetLerpValue(ClockPulse, Min, Max, Speed)
        elseif Mode == "Random" then
            return mathrandom(Min * 100, Max * 100) / 100
        end
    end
    return 0
end

function Desync:OverwritePosition(position)
    self.Overwriten = position
end

function Desync:RemoveOverwrite()
    self.Overwriten = nil
end

local function isClonedCharacterValid(self)
    return self.ClonedCharacter and self.ClonedCharacter.Character and self.ClonedCharacter.Character.Parent
end

function Desync:CloneCharacter()
    local Character = getgenv().Controller.Character
    if not Character then return end
    Character.Archivable = true
    local ClonedCharacter = Character:Clone()
    ClonedCharacter.Archivable = true
    ClonedCharacter.Name = "\0"
    ClonedCharacter.Parent = workspace
    Character.Archivable = false
    local Humanoid = ClonedCharacter:FindFirstChildWhichIsA("Humanoid")
    local HumanoidRootPart = Humanoid and Humanoid.Parent:FindFirstChild("HumanoidRootPart")
    for _,v in ipairs(ClonedCharacter:GetChildren()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            if v.Transparency ~= 1 then
                local Color = Flags["desync_vis_color"]
                local color3, alpha
                if typeof(Color) == "table" and Color.c then
                    color3 = Color.c
                    alpha = 1 - (Color.a or 0)
                elseif typeof(Color) == "Color3" then
                    color3 = Color
                    alpha = 1
                else
                    color3 = Color3.new(1,1,1)
                    alpha = 1
                end
                if Visuals.ApplyChams then
                    Visuals:ApplyChams(v, "ForceField", color3, alpha, 0)
                else
                    v.Material = Enum.Material.ForceField
                end
            end
            v.CanCollide = false
        else
            v:Destroy()
        end
    end
    if Humanoid then Humanoid:Destroy() end
    if HumanoidRootPart then HumanoidRootPart.Anchored = true end
    self.ClonedCharacter = { Character = ClonedCharacter, RootPart = HumanoidRootPart }
end

function Desync:UpdateCharacter()
    local ClonedCharacter = self.ClonedCharacter
    if ClonedCharacter then
        local Character = ClonedCharacter.Character
        if Character then
            for _,v in ipairs(Character:GetChildren()) do
                if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
                    if v.Transparency ~= 1 then
                        local Color = Flags["desync_vis_color"]
                        local color3, alpha
                        if typeof(Color) == "table" and Color.c then
                            color3 = Color.c
                            alpha = 1 - (Color.a or 0)
                        elseif typeof(Color) == "Color3" then
                            color3 = Color
                            alpha = 1
                        else
                            color3 = Color3.new(1,1,1)
                            alpha = 1
                        end
                        if Visuals.ApplyChams then
                            Visuals:ApplyChams(v, "ForceField", color3, alpha, 0)
                        else
                            v.Material = Enum.Material.ForceField
                        end
                    end
                end
            end
        end
    end
end

function Desync:DestroyClonedCharacter()
    local ClonedCharacter = self.ClonedCharacter
    if ClonedCharacter and ClonedCharacter.Character then
        ClonedCharacter.Character:Destroy()
        self.ClonedCharacter = nil
    end
end

-- Функция для обновления цвета клона
function Desync:CloneColorUpdate()
    if not self.ClonedCharacter then return end
    local Character = self.ClonedCharacter.Character
    if not Character then return end
    for _,v in ipairs(Character:GetChildren()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            if v.Transparency ~= 1 then
                local Color = Flags["desync_vis_color"]
                local color3, alpha
                if typeof(Color) == "table" and Color.c then
                    color3 = Color.c
                    alpha = 1 - (Color.a or 0)
                elseif typeof(Color) == "Color3" then
                    color3 = Color
                    alpha = 1
                else
                    color3 = Color3.new(1,1,1)
                    alpha = 1
                end
                if Visuals.ApplyChams then
                    Visuals:ApplyChams(v, "ForceField", color3, alpha, 0)
                else
                    v.Material = Enum.Material.ForceField
                end
            end
        end
    end
end

function Desync:Think()
    local Root = getgenv().Controller.RootPart
    local Status = self:Active()
    local Positions = self.Positions
    local ClonedCharacter = self.ClonedCharacter
    if not Status then
        Positions.Old = nil
        Positions.New = nil
        if isClonedCharacterValid(self) then self:DestroyClonedCharacter() end
        return
    end
    if not Flags["desync_vis"] and isClonedCharacterValid(self) then self:DestroyClonedCharacter() end
    if Flags["desync_vis"] and not isClonedCharacterValid(self) then self:CloneCharacter() end
    ClonedCharacter = self.ClonedCharacter
    Positions.Old = Root.CFrame
    if self.Overwriten then
        Root.CFrame = CFramenew(self.Overwriten)
    else
        local DesyncFactor = CFramenew(Vector3new(
            self:GetValue("x"),
            self:GetValue("y"),
            self:GetValue("z")
        ))
        DesyncFactor = DesyncFactor * CFrameAngles(
            mathrad(self:GetValue("pitch")),
            mathrad(self:GetValue("yaw")),
            mathrad(self:GetValue("roll"))
        )
        Root.CFrame = Root.CFrame * DesyncFactor
    end
    Positions.New = Root.CFrame
    if ClonedCharacter and ClonedCharacter.RootPart then
        ClonedCharacter.RootPart.CFrame = Positions.New
    end
    RunService.RenderStepped:Wait()
    Root.CFrame = Positions.Old
end

-- Heartbeat
RunService.Heartbeat:Connect(function()
    Desync:Think()
end)

-- Hook на CFrame
local OldIndex
OldIndex = hookmetamethod(game, "__index", newcclosure(function(self, prop)
    if not checkcaller() then
        if prop == "CFrame" then
            if Desync:Active() and Flags["desync_hook"] and self == getgenv().Controller.RootPart then
                local OldPosition = Desync:GetPositions()
                if OldPosition then
                    return OldPosition
                end
            end
        end
    end
    return OldIndex(self, prop)
end))

-- Offset fix
if not Flags["desync_hook"] then
    Desync:RemoveOffset()
end
-- =====================
-- КОНЕЦ DESYNC LOGIC (фикс)
-- =====================

-- Переменная для хранения текущей подписки на здоровье цели
getgenv()._targetHealthConn = nil
getgenv()._lastTarget = nil

-- Функция для отслеживания урона по цели
local function trackTargetHealth(targetPlayer)
    -- Очищаем предыдущую подписку
    if getgenv()._targetHealthConn then
        getgenv()._targetHealthConn:Disconnect()
        getgenv()._targetHealthConn = nil
    end
    if not targetPlayer or not targetPlayer.Character then return end
    local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local lastHealth = humanoid.Health
    getgenv()._targetHealthConn = humanoid.HealthChanged:Connect(function(newHealth)
        if newHealth < lastHealth then
            local damage = lastHealth - newHealth
            -- Можно определить часть тела через Raycast или логику попадания, пока "Unknown"
            getgenv().OnTargetHit(targetPlayer, damage, newHealth, "Unknown", function(msg)
                if getgenv().library and getgenv().library.Notify then
                    getgenv().library:Notify({Text = msg, Time = 2})
                end
            end)
            lastHealth = newHealth
        elseif newHealth < humanoid.MaxHealth then
            -- обновляем lastHealth только если не хилл, чтобы не реагировать на хилл
            lastHealth = newHealth
        end
    end)
    humanoid.Died:Connect(function()
        if getgenv()._targetHealthConn then
            getgenv()._targetHealthConn:Disconnect()
            getgenv()._targetHealthConn = nil
        end
    end)
end

-- Хук на выбор новой цели аимбота (TP)
local oldTP = getgenv().TP
local function checkTargetChange()
    if getgenv().TP ~= getgenv()._lastTarget then
        getgenv()._lastTarget = getgenv().TP
        if getgenv().TP then
            trackTargetHealth(getgenv().TP)
        else
            if getgenv()._targetHealthConn then
                getgenv()._targetHealthConn:Disconnect()
                getgenv()._targetHealthConn = nil
            end
        end
    end
end
-- Проверяем смену цели каждый кадр
getgenv().S.RunS.RenderStepped:Connect(checkTargetChange)

-- Добавляем секцию Spoofers во вкладку Misc
getgenv().SpoofersSection = getgenv().Misc:CreateSection({ Name = "Spoofers" })

-- Ping Spoofer UI
getgenv().PingSpoofToggle = getgenv().SpoofersSection:AddToggle({
    Name = "Ping Spoofer",
    Flag = "ping_spoofer_enabled",
    Value = false
})
getgenv().PingSpoofMin = getgenv().SpoofersSection:AddTextbox({
    Name = "Min Ping",
    Flag = "ping_spoofer_min",
    Value = 20,
    Type = "number"
})
getgenv().PingSpoofMax = getgenv().SpoofersSection:AddTextbox({
    Name = "Max Ping",
    Flag = "ping_spoofer_max",
    Value = 50,
    Type = "number"
})

-- Memory Spoofer UI
getgenv().MemorySpoofToggle = getgenv().SpoofersSection:AddToggle({
    Name = "Memory Spoofer",
    Flag = "memory_spoofer_enabled",
    Value = false
})
getgenv().MemorySpoofMin = getgenv().SpoofersSection:AddTextbox({
    Name = "Min Memory",
    Flag = "memory_spoofer_min",
    Value = 800,
    Type = "number"
})
getgenv().MemorySpoofMax = getgenv().SpoofersSection:AddTextbox({
    Name = "Max Memory",
    Flag = "memory_spoofer_max",
    Value = 1100,
    Type = "number"
})

-- Локальная логика спуферов
local function spoofPing()
    local minPing = tonumber(getgenv().PingSpoofMin:Get()) or 20
    local maxPing = tonumber(getgenv().PingSpoofMax:Get()) or 50
    local PingLabel
    for _, v in pairs(game.CoreGui.RobloxGui.PerformanceStats:GetChildren()) do
        if v.Name == "PS_Button" and v.StatsMiniTextPanelClass.TitleLabel.Text == "Ping" then
            PingLabel = v.StatsMiniTextPanelClass.ValueLabel
            break
        end
    end
    if PingLabel then
        local updating = false
        PingLabel:GetPropertyChangedSignal("Text"):Connect(function()
            if not getgenv().PingSpoofToggle:Get() then return end
            if updating then return end
            updating = true
            local fakePing = math.random(minPing, maxPing)
            PingLabel.Text = fakePing .. " ms"
            updating = false
        end)
    end
end

local function spoofMemory()
    local minMem = tonumber(getgenv().MemorySpoofMin:Get()) or 800
    local maxMem = tonumber(getgenv().MemorySpoofMax:Get()) or 1100
    local MemoryLabel
    for _, v in pairs(game.CoreGui.RobloxGui.PerformanceStats:GetChildren()) do
        if v.Name == "PS_Button" and v.StatsMiniTextPanelClass.TitleLabel.Text == "Mem" then
            MemoryLabel = v.StatsMiniTextPanelClass.ValueLabel
            break
        end
    end
    if MemoryLabel then
        MemoryLabel:GetPropertyChangedSignal("Text"):Connect(function()
            if not getgenv().MemorySpoofToggle:Get() then return end
            local Random = math.random(minMem, maxMem)
            Random = math.floor(Random * 1.23)
            MemoryLabel.Text = tostring(Random) .. " MB"
        end)
    end
end

-- Автоматически активируем спуферы при включении тоглов
if getgenv().PingSpoofToggle:Get() then spoofPing() end
getgenv().PingSpoofToggle.Options.Callback = function(v)
    if v then spoofPing() end
end
if getgenv().MemorySpoofToggle:Get() then spoofMemory() end
getgenv().MemorySpoofToggle.Options.Callback = function(v)
    if v then spoofMemory() end
end

-- Добавляем новую секцию Visuals справа во вкладку Rage
getgenv().RageVisualsSection = getgenv().Rage:CreateSection({ Name = "Visuals", Side = "Right" })

-- Тогл HitChams
getgenv().HitChamsToggle = getgenv().RageVisualsSection:AddToggle({
    Name = "HitChams",
    Flag = "rage_hit_chams",
    Value = false
})

-- Настройки HitChams
getgenv().HitChamsColor = getgenv().RageVisualsSection:AddColorpicker({
    Name = "HitChams Color",
    Flag = "rage_hit_chams_color",
    Value = Color3.fromRGB(255,0,0)
})
getgenv().HitChamsMaterial = getgenv().RageVisualsSection:AddDropdown({
    Name = "HitChams Material",
    Flag = "rage_hit_chams_material",
    List = {"Neon", "ForceField", "Plastic", "SmoothPlastic", "Glass", "Metal"},
    Value = "Neon"
})
getgenv().HitChamsTransparency = getgenv().RageVisualsSection:AddSlider({
    Name = "HitChams Transparency",
    Flag = "rage_hit_chams_transparency",
    Min = 0,
    Max = 1,
    Decimals = 2,
    Value = 0
})
getgenv().HitChamsDuration = getgenv().RageVisualsSection:AddSlider({
    Name = "HitChams Duration",
    Flag = "rage_hit_chams_duration",
    Min = 0.1,
    Max = 5,
    Decimals = 1,
    Value = 2
})

-- Логика HitChams с учётом настроек
local function HitChams(Player)
    if not Player or not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return end

    local BodyParts = {
        "Head", "UpperTorso", "LowerTorso",
        "LeftUpperArm", "LeftLowerArm", "LeftHand",
        "RightUpperArm", "RightLowerArm", "RightHand",
        "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
        "RightUpperLeg", "RightLowerLeg", "RightFoot"
    }

    Player.Character.Archivable = true
    local Cloned = Player.Character:Clone()
    Cloned.Archivable = true
    Cloned.Name = "HitChamsClone"
    Cloned.Parent = workspace -- НЕ в Player, а в workspace

    -- Удаляем всё, что не части тела r15
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then
            local valid = false
            for _, validPart in ipairs(BodyParts) do
                if Part.Name == validPart then valid = true break end
            end
            if not valid then Part:Destroy() end
        elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
            Part:Destroy()
        end
    end

    if Cloned:FindFirstChild("Humanoid") then Cloned.Humanoid:Destroy() end

    -- Смещение клона чуть выше (-0.2 по Y)
    if Cloned:FindFirstChild("HumanoidRootPart") then
        Cloned:SetPrimaryPartCFrame(Cloned.HumanoidRootPart.CFrame + Vector3.new(0, -0.2, 0))
    end

    local color = getgenv().HitChamsColor and getgenv().HitChamsColor:Get() or Color3.fromRGB(255,0,0)
    local materialName = getgenv().HitChamsMaterial and getgenv().HitChamsMaterial:Get() or "Neon"
    local material = Enum.Material[materialName] or Enum.Material.Neon
    local transparency = getgenv().HitChamsTransparency and getgenv().HitChamsTransparency:Get() or 0
    local duration = getgenv().HitChamsDuration and getgenv().HitChamsDuration:Get() or 2

    for _, BodyPart in ipairs(Cloned:GetChildren()) do
        if BodyPart:IsA("BasePart") then
            BodyPart.CanCollide = false
            BodyPart.Anchored = true
            BodyPart.Transparency = transparency
            BodyPart.Color = color
            BodyPart.Material = material
        end
    end

    if Cloned:FindFirstChild("Head") then
        local Head = Cloned.Head
        Head.Transparency = transparency
        Head.Color = color
        Head.Material = material
        if Head:FindFirstChild("face") then Head.face:Destroy() end
        Head.CanCollide = false
        Head.Anchored = true
    end

    Cloned.Parent = workspace

    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false)
    local TweenService = game:GetService("TweenService")
    for _, BodyPart in ipairs(Cloned:GetChildren()) do
        if BodyPart:IsA("BasePart") then
            local tween = TweenService:Create(BodyPart, tweenInfo, { Transparency = 1 })
            tween:Play()
        end
    end

    task.delay(duration, function()
        if Cloned and Cloned.Parent then Cloned:Destroy() end
    end)
end

-- Добавляем секцию HitSkeletons справа во вкладку Rage
getgenv().RageHitSkeletonsSection = getgenv().Rage:CreateSection({ Name = "HitSkeletons", Side = "Right" })

-- Тогл HitSkeletons
getgenv().HitSkeletonsToggle = getgenv().RageHitSkeletonsSection:AddToggle({
    Name = "HitSkeletons",
    Flag = "rage_hit_skeletons",
    Value = false
})

-- Логика HitSkeleton
local function HitSkeleton(Player, color, transparency, duration)
    if not Player or not Player.Character then return end
    local bones = {
        {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightLowerArm", "RightHand"},
        {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"},
        {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"},
        {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"}
    }
    local lines = {}
    for _, pair in ipairs(bones) do
        local a = Player.Character:FindFirstChild(pair[1])
        local b = Player.Character:FindFirstChild(pair[2])
        if a and b then
            local line = Instance.new("Part")
            line.Size = Vector3.new(0.02, 0.02, (a.Position - b.Position).Magnitude)
            line.CFrame = CFrame.new(a.Position, b.Position) * CFrame.new(0, 0, -line.Size.Z/2)
            line.Anchored = true
            line.CanCollide = false
            line.Transparency = transparency or 0.5
            line.Color = color or Color3.fromRGB(155,0,155)
            line.Material = Enum.Material.Neon
            line.Parent = workspace
            table.insert(lines, line)
        end
    end
    task.delay(duration or 2, function()
        for _, line in ipairs(lines) do if line and line.Parent then line:Destroy() end end
    end)
end

-- Добавляем секцию HitSounds справа во вкладку Rage
getgenv().RageHitSoundsSection = getgenv().Rage:CreateSection({ Name = "HitSounds", Side = "Right" })

-- Список ассетов
getgenv().HitSoundAssets = {
    ["None"] = '',
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bubble"] = "rbxassetid://6534947588",
    ["Minecraft"] = "rbxassetid://8837706727",
    ["Cod"] = "rbxassetid://160432334",
    ["Bameware"] = "rbxassetid://3124331820",
    ["Neverlose"] = "rbxassetid://6534948092",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Rust"] = "rbxassetid://1255040462",
    ["Bruh"] = "rbxassetid://4578740568",
    ["Bell"] = "rbxassetid://6534947240",
    ["Pick"] = "rbxassetid://1347140027",
    ["Pop"] = "rbxassetid://198598793",
    ["Sans"] = "rbxassetid://3188795283",
    ["Fart"] = "rbxassetid://130833677",
    ["Big"] = "rbxassetid://5332005053",
    ["Vine"] = "rbxassetid://5332680810",
    ["Fatality"] = "rbxassetid://6534947869",
    ["Bonk"] = "rbxassetid://5766898159",
    ["Totem"] = "rbxassetid://135055101757201",
    ["CSHS"] = "rbxassetid://9065951723",
    ["OSU"] = "rbxassetid://7147454322",
    ["Hitmarker"] = "rbxassetid://160432334",
    ["skeet"] = "rbxassetid://4817809188",
    ["Lazer Beam"] = "rbxassetid://130791043",
    ["Bow Hit"] = "rbxassetid://1053296915",
    ["Bow"] = "rbxassetid://3442683707",
    ["TF2 Hitsound"] = "rbxassetid://3455144981",
    ["TF2 Critical"] = "rbxassetid://296102734"
}

-- Тогл включения
getgenv().HitSoundToggle = getgenv().RageHitSoundsSection:AddToggle({
    Name = "Enable HitSound",
    Flag = "rage_hit_sound_enabled",
    Value = false
})
-- Dropdown для выбора звука
getgenv().HitSoundDropdown = getgenv().RageHitSoundsSection:AddDropdown({
    Name = "HitSound",
    Flag = "rage_hit_sound",
    List = (function() local t = {} for k in pairs(getgenv().HitSoundAssets) do table.insert(t, k) end; table.sort(t); return t end)(),
    Value = "Bameware"
})
-- Pitch
getgenv().HitSoundPitch = getgenv().RageHitSoundsSection:AddSlider({
    Name = "Pitch",
    Flag = "rage_hit_sound_pitch",
    Min = 0.5,
    Max = 2,
    Decimals = 2,
    Value = 1
})
-- Volume
getgenv().HitSoundVolume = getgenv().RageHitSoundsSection:AddSlider({
    Name = "Volume",
    Flag = "rage_hit_sound_volume",
    Min = 0,
    Max = 5,
    Decimals = 2,
    Value = 1
})

-- Функция проигрывания звука
local function PlayHitSound()
    if not (getgenv().HitSoundToggle and getgenv().HitSoundToggle:Get()) then return end
    local soundName = getgenv().HitSoundDropdown and getgenv().HitSoundDropdown:Get() or "Bameware"
    local soundId = getgenv().HitSoundAssets[soundName] or "rbxassetid://3124331820"
    if not soundId or soundId == '' then return end
    local pitch = getgenv().HitSoundPitch and getgenv().HitSoundPitch:Get() or 1
    local volume = getgenv().HitSoundVolume and getgenv().HitSoundVolume:Get() or 1
    local SoundService = game:GetService("SoundService")
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Parent = SoundService
    sound.Volume = volume
    sound.PlaybackSpeed = pitch
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)
end

-- Основная логика обработки попадания по цели (делаем глобальной)
getgenv().OnTargetHit = function(targetPlayer, damage, remainingHealth, partName, notifyCallback)
    if notifyCallback then
        notifyCallback(string.format("Hit %s on %s for %d (%d left)", targetPlayer.DisplayName, partName, damage, remainingHealth))
    end
    -- HitChams
    if getgenv().HitChamsToggle and getgenv().HitChamsToggle:Get() then
        HitChams(targetPlayer)
    end
    -- HitSkeletons
    if getgenv().HitSkeletonsToggle and getgenv().HitSkeletonsToggle:Get() then
        local color = getgenv().HitChamsColor and getgenv().HitChamsColor:Get() or Color3.fromRGB(155,0,155)
        local transparency = getgenv().HitChamsTransparency and getgenv().HitChamsTransparency:Get() or 0.5
        local duration = getgenv().HitChamsDuration and getgenv().HitChamsDuration:Get() or 2
        HitSkeleton(targetPlayer, color, transparency, duration)
    end
    -- HitSound
    PlayHitSound()
    -- Здесь можно добавить HitEffect
end
